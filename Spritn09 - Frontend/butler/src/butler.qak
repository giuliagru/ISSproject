System -msglog butler
mqttBroker "localhost" : 1883 eventTopic "unibo/qak/events" 

//user events 
Event prepare_button : prepare_button(Cmd)
Event clear_button : clear_button(Cmd)
Event add_button : add_button(Foodcode, Quantity)
Event exposefridgestate_button : exposefridgestate_button(Cmd)
Event exposeroomstate_button : exposeroomstate_button(Cmd)

Event pantryState : pantryState(pantryState,X)

//maitre messages
Dispatch prepare : prepare(Cmd)
Dispatch clear : clear(Cmd)
Dispatch add : add(Foodcode, Quantity)

Request exposefridgestate : exposefridgestate(Cmd)
Reply fridgestate: fridgestate(List)

Request exposeroomstate : exposeroomstate(Cmd)
Reply roomstate : roomstate(List)

//robot movements
Dispatch goto : goto(Destination)
Dispatch arrivedat : arrivedat(Destination)

//roomstate updates
Dispatch updateState : updateState(Action)

//robot-fridge interaction
Request check_food : check_food(Foodcode, Quantity) 
Reply food_available : food_available(Foodcode, Quantity)
Reply food_notavailable : food_notavailable(Foodcode, Quantity)

Dispatch food_notavailable : food_notavailable(Foodcode, Quantity)
Dispatch take_food : take_food(Foodcode, Quantity)
Dispatch take_foodlist : take_foodlist(List)


Dispatch cmd       	: cmd(MOVE)    
Dispatch end       	: end(ARG) 
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
  
Event   obstacle   : obstacle( ARG ) 
Event  endall	   : endall( ARG )  

//mqttBroker localhost : 1883 
 
Context ctxbasicrobot ip [host="localhost" port=8020] 

//contexts
//Context ctxrobot ip [host="127.0.0.1" port=8093]  
//Context ctxmaitre ip [host="127.0.0.1" port=8094]
Context ctxfridge ip [host="127.0.0.1" port=8092]

ExternalQActor basicrobot context ctxbasicrobot

//Fridge
//TODO: rendere il frigo un server COAP
QActor fridge context ctxfridge{
	State s0 initial{
		solve( consult("sysRules.pl")	 )
		solve( consult("fridgestate.pl")	 )
		println("Fridge is ready")
		//run itunibo.coap.fridge.fridgeCoap.create(myself, "serverfridge") //CoAP access
//	}
	}Goto waitMsg
	
	State waitMsg{
		
	}Transition t0
		whenRequest check_food -> check
		whenMsg take_food -> take
		whenMsg take_foodlist -> take
		whenRequest exposefridgestate -> exposestate
	
	//check food availability
	State check {
		onMsg(check_food : check_food(Foodcode, Quantity)){
			solve(check($payloadArg(0),$payloadArg(1) ))
			ifSolved {replyTo check_food with food_available : food_available($payloadArg(0),$payloadArg(1))}
			else {replyTo check_food with food_notavailable : food_notavailable($payloadArg(0),$payloadArg(1))}
		}
	} Goto waitMsg
	
	//take food 
	State take{
		onMsg(take_food: take_food(Foodcode, Quantity)){
			solve(action(take, fridge, food, $payloadArg(0), $payloadArg(1)))
			ifSolved {
				println("Fridge: ${payloadArg(0)} taken")
			}			
		}
		
		onMsg(take_foodlist: take_foodlist(L)){
			[# var Food: String = payloadArg(0);
				 var Foodstring = Food.replace(",(","(") #] //to remove the extra comma from prolog toString
			//println(Foodstring)
			solve(text_term($Foodstring,E))
			ifSolved{
				[#var Sol = getCurSol("E");
						var Solstring = Sol.toString()#]
				solve(action(take, fridge, food, $Sol))
				ifSolved {
					println("Fridge: $Food taken")					
				}
			}			
		}
		
	}Goto exposestate
	
	//expose fridge state to maitre
	State exposestate{
		solve(state(fridge, List))
		ifSolved{
			println("fridge has ${getCurSol(\"List\")}")
			replyTo exposefridgestate with fridgestate : fridgestate($getCurSol("List")) 
			[#				
				val L = getCurSol("List").toString()
				val my = myself							
				val t = utils.stringFormat.prepareToSend(L)	
				val OnFridge = t["fridge"].toString()				
			#]
			run utils.utilsFrontend.updateFrontend(my, OnFridge)
		}
	}Goto waitMsg
}

//Butler movements 
QActor robotmover context ctxfridge{
	[#  
		val map = "roommap"
		var Curmove     = "" 
		var curmoveIsForward = false 
		var Direction = ""
		
		//REAL ROBOT
		//var StepTime   = 1000 	 
		//var PauseTime  = 500 
		
		//VIRTUAL ROBOT
		var StepTime   = 330	//for virtual
		var PauseTime  = 500
		
		var PauseTimeL  = PauseTime.toLong()
		val my = myself
	#]
	State s0 initial {
		solve( consult("sysRules.pl")	 )
		solve( consult("roomcoordinates.pl"))
		solve( consult("moves.pl")	)
		run itunibo.planner.plannerUtil.initAI()
  		[# itunibo.planner.moveUtils.loadRoomMap(myself, map)#]	
  		run itunibo.planner.moveUtils.showCurrentRobotState()
	} Goto waitCmd
	
	State waitCmd{	}
	Transition t0
		whenMsg goto -> moving	
		
	State moving {
		onMsg(goto: goto(Destination)){
			println("going to ${payloadArg(0)}")
			solve(position($payloadArg(0), X, Y, D))
			[#
				
				val X = getCurSol("X").toString()
				val Y = getCurSol("Y").toString()
				Direction = getCurSol("D").toString()
				val dest =":" + payloadArg(0) +" (" + X + "," +Y+")"
			#]

			run utils.utilsFrontend.updateGoalToFrontend(my,dest)
//			[#	val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()  #]
//	 		forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)
			run itunibo.planner.plannerUtil.setGoal(X,Y)
			
  			[# itunibo.planner.moveUtils.doPlan( myself )#]
			
		}
	}Goto execplanaction
	
	State execplanaction{
		solve( retract( move(M) ) ) 
			ifSolved {  
				[#Curmove = getCurSol("M").toString() 
	              curmoveIsForward=(Curmove == "w")
		        #]
			} else { [#Curmove = ""; curmoveIsForward=false#]  }  
			//println("executePlannedActions doing $Curmove")
	 	}
		Goto checkAndDoAction  if [#(Curmove.length>0)#] else goalOk 
	
 	State goalOk{		  
 		//run itunibo.planner.moveUtils.showCurrentRobotState()
	 	//[#	val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()  #]
	 	[#itunibo.applUtil.applUtil.changeDirection( myself, Direction )#]
	 	forward robotexecutor -m arrivedat: arrivedat($payloadArg(0))
	}Goto waitCmd
		
		//Execute the move if it is a rotation or halt
	State checkAndDoAction{	 }
	Goto doForwardMove if [#curmoveIsForward#] else doTheMove
	  
	State doTheMove{
		delayVar PauseTimeL
 		[#itunibo.planner.moveUtils.rotate(myself, Curmove, PauseTime)#] //modifies also the planner state
 		
 		//println("robot doing $Curmove")
 		//forward basicrobot -m cmd:cmd($Curmove) 		 
  	}
	Goto execplanaction
	
 	State doForwardMove{
 		delayVar PauseTimeL  //Otherwise is too fast, even with remote interaction
 		//[#itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime)#] //forwards to stepahead
 		request basicrobot -m step : step ($StepTime)
 		//forward basicrobot -m step : step($StepTime)
	} 
	Transition t0   //whenEvent stopAppl -> handleStopAppl
					whenReply stepdone     -> handleStepOk   
					whenReply stepfail   -> hadleStepFail 	
    	
//TODO    	
//   State handleStopAppl{
//    	println("APPLICATION STOPPED. Waiting for a reactivate")
//    } 
//    Transition t0  whenEvent reactivateAppl -> handleReactivateAppl
//    
//    State handleReactivateAppl{
//    	println("APPLICATION RESUMED")
//    } 
//	Transition t0   whenMsg stepOk   -> handleStepOk   
//					whenMsg stepFail -> hadleStepFail 	
    
	State handleStepOk{
 		[#itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
 		var c = ":" + utils.stringFormat.formatPosition(my)#] 
 		run utils.utilsFrontend.updatePositionFrontend(my,c)
	}
	Goto execplanaction
	 
	/*We could reach this state since the robot moves are not precise enough */
 	State hadleStepFail{ 
		println("NEVER HERE!!!")
		[#val ButlerDirection = itunibo.planner.moveUtils.getDirection(myself)#]
		println("ButlerDirection = $ButlerDirection")
		//Move a little bit backward
		forward basicrobot -m cmd : cmd( s )
		delay 50
		forward basicrobot -m cmd : cmd( h )
	}
	Goto execplanaction
}

QActor roomstate context ctxfridge{
	State s0 initial{
		solve( consult("sysRules.pl")	 )
		solve( consult("roomstate.pl")	 )
		solve( consult("preparerequirements.pl") )
	}Goto waitStateChange
	
	State waitStateChange{	}
		Transition t1
		whenRequest exposeroomstate -> handleexposeroomstate
		whenMsg updateState -> update
	
	State handleexposeroomstate{
		onMsg(exposeroomstate : exposeroomstate(Cmd)){
			solve(roomstate(St))
			ifSolved{
			[#				
				val L = getCurSol("St").toString()
				val my = myself							
				val t = utils.stringFormat.prepareToSend(L)	
				val OnRobot = t["robot"].toString()
				val OnPantry = t["pantry"].toString()
				val OnDish = t["dishwasher"].toString()
				val OnTable = t["table"].toString()
			#]
			run utils.utilsFrontend.updateFrontend(my, OnRobot)
			run utils.utilsFrontend.updateFrontend(my, OnPantry)
			run utils.utilsFrontend.updateFrontend(my, OnDish)
			run utils.utilsFrontend.updateFrontend(my, OnTable)
				//println("room has ${getCurSol(\"St\")}")
				replyTo exposeroomstate with roomstate : roomstate($getCurSol("St"))
			}
		}
	}Goto waitStateChange
	
	State update{
		onMsg(updateState : updateState(preparedishes)){
			solve(dishes(D))
			[#
				var Sol = getCurSol("D")
			#]
			solve(action(take,pantry,dishes,$Sol))	
			solve(roomstate(L))
			println("room has ${getCurSol(\"L\")}")

			[#				
				val L = getCurSol("L").toString()
				val my = myself							
				val t = utils.stringFormat.prepareToSend(L)	
				val OnRobot = t["robot"].toString()
				val OnPantry = t["pantry"].toString()
				val OnDish = t["dishwasher"].toString()
				val OnTable = t["table"].toString()
			#]
			println(t)

			run utils.utilsFrontend.updateFrontend(my, OnRobot)
			run utils.utilsFrontend.updateFrontend(my, OnPantry)
			run utils.utilsFrontend.updateFrontend(my, OnDish)
			run utils.utilsFrontend.updateFrontend(my, OnTable)

		}
		onMsg(updateState : updateState(preparefood)){
			solve(food(F))
			[#
				var Sol = getCurSol("F")
			#]
			solve(action(take,fridge,food,$Sol))	
			solve(roomstate(L))
			println("room has ${getCurSol(\"L\")}")
			[#				
				val L = getCurSol("L").toString()
				val my = myself							
				val t = utils.stringFormat.prepareToSend(L)	
				val OnRobot = t["robot"].toString()
				val OnPantry = t["pantry"].toString()
				val OnTable = t["table"].toString()
				val OnDish = t["dishwasher"].toString()
			#]
			println(t)

			run utils.utilsFrontend.updateFrontend(my, OnRobot)
			run utils.utilsFrontend.updateFrontend(my, OnPantry)
			run utils.utilsFrontend.updateFrontend(my, OnTable)
			run utils.utilsFrontend.updateFrontend(my, OnDish)
		}
		
		
		onMsg(updateState : updateState(action(A,B,C))){
			solve($payloadArg(0))
			solve(roomstate(L))
			println("room has ${getCurSol(\"L\")}")
			[#				
				val L = getCurSol("L").toString()
				val my = myself							
				val t = utils.stringFormat.prepareToSend(L)	
				val OnRobot = t["robot"].toString()
				val OnPantry = t["pantry"].toString()
				val OnTable = t["table"].toString()
				val OnDish = t["dishwasher"].toString()
			#]
			println(t)

			run utils.utilsFrontend.updateFrontend(my, OnRobot)
			run utils.utilsFrontend.updateFrontend(my, OnPantry)
			run utils.utilsFrontend.updateFrontend(my, OnTable)
			run utils.utilsFrontend.updateFrontend(my, OnDish)
		}
		onMsg(updateState : updateState(action(A,B,C,D))){
			solve($payloadArg(0))
			solve(roomstate(L))
			println("room has ${getCurSol(\"L\")}")
			[#				
				val L = getCurSol("L").toString()
				val my = myself							
				val t = utils.stringFormat.prepareToSend(L)	
				val OnRobot = t["robot"].toString()
				val OnPantry = t["pantry"].toString()
				val OnTable = t["table"].toString()
				val OnDish = t["dishwasher"].toString()
			#]
			println(t)

			run utils.utilsFrontend.updateFrontend(my, OnRobot)
			run utils.utilsFrontend.updateFrontend(my, OnPantry)
			run utils.utilsFrontend.updateFrontend(my, OnTable)
			run utils.utilsFrontend.updateFrontend(my, OnDish)
		}
		onMsg(updateState : updateState(action(A,B,C,D,E))){
			solve($payloadArg(0))
			solve(roomstate(L))
			println("room has ${getCurSol(\"L\")}")
			[#				
				val L = getCurSol("L").toString()
				val my = myself							
				val t = utils.stringFormat.prepareToSend(L)	
				val OnRobot = t["robot"].toString()
				val OnPantry = t["pantry"].toString()
				val OnTable = t["table"].toString()
				val OnDish = t["dishwasher"].toString()
			#]
			println(t)

			run utils.utilsFrontend.updateFrontend(my, OnRobot)
			run utils.utilsFrontend.updateFrontend(my, OnPantry)
			run utils.utilsFrontend.updateFrontend(my, OnTable)
			run utils.utilsFrontend.updateFrontend(my, OnDish)
		}
	}Goto waitStateChange
}

QActor robotexecutor context ctxfridge{
	[#	val my = myself		#]
	State s0 initial{
		solve( consult("preparerequirements.pl") )
	}
	
	Goto waitCmd
	
	State waitCmd{}
	Transition t0
		whenMsg prepare->handleprepare
		whenMsg add ->handleadd
		whenMsg clear ->handleclear
	
	State handleprepare{
		onMsg (prepare: prepare(X)){
			println("Prepare: start")
			run utils.utilsFrontend.updateTaskFrontend(my,":PREPARE")
			//println("Going to pantry..")
			forward robotmover -m goto : goto(pantry)
		}
	}Transition t1
		whenMsg arrivedat-> atpantry
		
	State atpantry{
		onMsg(arrivedat:arrivedat(pantry)){	
			forward roomstate -m updateState : updateState(preparedishes) 
			println("dishes taken")
			forward robotmover -m goto : goto(table)
		}
	}Transition t2
		whenMsg arrivedat-> attable_dishes
		
	State attable_dishes{
		onMsg(arrivedat:arrivedat(table)){
			forward roomstate -m updateState : updateState(action(put, table, dishes))
			println( "dishes on table " )
			forward robotmover -m goto:goto(fridge)
		}
	}Transition t3
		whenMsg arrivedat -> atfridge 
	
	State atfridge{
		onMsg(arrivedat:arrivedat(fridge)){	
			solve(food(F))
			forward fridge -m take_foodlist : take_foodlist($getCurSol("F"))

			forward roomstate -m updateState : updateState(preparefood)
			println("food taken")
			forward robotmover -m goto : goto(table)		
		}
		
	}Transition t5
		whenMsg arrivedat -> attable_food
		
	State attable_food{
		onMsg(arrivedat:arrivedat(table)){
			forward roomstate -m updateState : updateState(action(put, table, food))	
			println("food on table")		
			forward robotmover -m goto : goto(home)
		}	
	}Transition t6
		whenMsg arrivedat -> endPrepare
	
	State endPrepare {
		println("")
		println("ADD: State AddFoodEnded")
		println("ADD terminata")		
		run utils.utilsFrontend.updateFrontend(my, "endPrepare")
	}	
		Goto waitCmd 
	
	State handleadd{
		onMsg (add: add(Food, Quantity)){
			run utils.utilsFrontend.updateTaskFrontend(my,":ADD")
			println("\\nAdd: start")
			println("check food ${payloadArg(0)}")
		}
		request fridge -m check_food : check_food( $payloadArg(0), $payloadArg(1))
		
	}Transition t7 
		whenReply food_available -> tofridge
		whenReply food_notavailable -> alertMaitre
	
	State tofridge{
		onMsg (food_available : food_available(Foodcode, Quantity)){
			println("${payloadArg(0)} ${payloadArg(1)} available")
			forward fridge -m take_food : take_food($payloadArg(0), $payloadArg(1))
			forward roomstate -m updateState : updateState(action(take, fridge, food, $payloadArg(0), $payloadArg(1)))	
			forward robotmover -m goto:goto(fridge)
			//dovrebbero stare nello stato sotto ma nn c'è conoscenza sui payload
				
		}
	}Transition t8
		whenMsg arrivedat -> takefood
		
	State takefood{
			onMsg(arrivedat : arrivedat(fridge)){
				
				println("food taken")
				forward robotmover -m goto : goto(table)
			}
		
	}Transition t10
		whenMsg arrivedat -> attable_food
		
	State alertMaitre{
		onMsg (food_notavailable : food_notavailable(Foodcode, Quantity)){
			println("${payloadArg(0)} not available")
		run utils.utilsFrontend.updateFrontend(my, "warning")
			forward maitre -m food_notavailable : food_notavailable($payloadArg(0), $payloadArg(1)) //TODO
		}
	}Goto waitCmd
	
	State handleclear{
		onMsg (clear: clear(X)){
		run utils.utilsFrontend.updateTaskFrontend(my,":CLEAR")	
		println("\\nClear: start")
		forward robotmover -m goto : goto(table)
		}
	}Transition t11
		whenMsg arrivedat -> cleartable_food
	
	State cleartable_food{
		onMsg(arrivedat:arrivedat(table))	{
			forward roomstate -m updateState : updateState(action(take, table, food))
			println("food taken from table")
			forward robotmover -m goto : goto(fridge)
			
		}
	}Transition t12
		whenMsg arrivedat -> leftoverstofridge
	
	State leftoverstofridge{
		onMsg(arrivedat:arrivedat(fridge)){	
			forward roomstate -m updateState : updateState(action(put, fridge, food))
			println("leftovers in the fridge")
			forward robotmover -m goto : goto(table)
		}
	}Transition t13
		whenMsg arrivedat -> cleartable_dishes
		
	State cleartable_dishes{
		onMsg(arrivedat:arrivedat(table))	{
			forward roomstate -m updateState : updateState(action(take, table, dishes))
			println("dishes taken from table")
			forward robotmover -m goto : goto(dishwasher)
		}
	}Transition t14
		whenMsg arrivedat -> dishestodishwasher
	
	State dishestodishwasher{
		onMsg(arrivedat:arrivedat(dishwasher)){
			forward roomstate -m updateState : updateState(action(put, dishwasher, dishes))
			println("dishes in the dishwasher")
			forward robotmover -m goto : goto(home)			
		}	
	}Transition t15
		whenMsg arrivedat -> endClear
		
	State endClear {
		println("")
		println("CLEAR: State ClearEnded")
		println("CLEAR terminata")		
		run utils.utilsFrontend.updateFrontend(my, "endClear")
	}	
		Goto waitCmd 
}

//Butler 
QActor robot context ctxfridge{
	State s0 initial{}
	Goto waitCmd
	
	State waitCmd{}
	Transition t0
		whenMsg prepare -> handleprepare
		whenMsg add -> handleadd
		whenMsg clear -> handleclear
		//whenMsg exposeroomstate -> handleexposeroomstate
		//whenMsg stop -> handlestop
		//whenMsg revive -> handlerevive
		
	State handleprepare{
		onMsg(prepare:prepare(X)){
			forward robotexecutor -m prepare : prepare($payloadArg(0))
		}
	}Goto waitCmd
	
	State handleadd{
		onMsg(add:add(Foodcode, Quantity)){
			forward robotexecutor -m add : add($payloadArg(0), $payloadArg(1))
		}
	}Goto waitCmd
	
	State handleclear{
		onMsg(clear:clear(X)){
			forward robotexecutor -m clear : clear($payloadArg(0))
		}
	}Goto waitCmd
		
	/*	
	State handleexposeroomstate{
		onMsg(exposeroomstate : exposeroomstate(Cmd)){
			
			solve(roomstate(St))
			ifSolved{
				//println("room has ${getCurSol(\"St\")}")
				forward maitre -m roomstate : roomstate(#St)
			}
		}
		
	}Goto waitCmd
	*/
}


//Maitre
QActor maitre context ctxfridge{
	State s0 initial{
		println("Maitre is ready")
	}
	Goto waitCmd
	
	State waitCmd{}
	Transition t0
		whenEvent prepare_button -> prepare
		whenEvent add_button -> add
		whenEvent clear_button -> clear
		whenEvent exposefridgestate_button -> exposefridge
		whenEvent exposeroomstate_button -> exposeroomstate
		whenMsg food_notavailable -> handlerobotmsg
	
	State prepare {
		onMsg(prepare_button: prepare_button(X)){
		println("maitre preparing")
		forward robot -m prepare : prepare(ok)
		
		}
	}	
	Goto waitCmd
		
	State add {
			onMsg(add_button: add_button(X, Y)){
			println("maitre adding: ${payloadArg(0)}")
			forward robot -m add : add($payloadArg(0), $payloadArg(1))		
		}
	}	
	Goto waitCmd
	
	State clear {
		onMsg(clear_button: clear_button(X)){
			println("maitre clearing")
		forward robot -m clear : clear(ok)
		
		}
	}
	Goto waitCmd
	
	//robot massage when the add Foodcode isn't available
	State handlerobotmsg{
		onMsg (food_notavailable: food_notavailable(Foodcode, Quantity)){
			println("maitre knows ${payloadArg(0)} isn't available")
		}
	}
	Goto waitCmd
	
	
	State exposefridge{
		onMsg(exposefridgestate_button: exposefridgestate_button(Cmd)){
			request fridge -m exposefridgestate : exposefridgestate(Cmd)
		}
	}Transition t1
	whenReply fridgestate -> waitfridge
	
	State waitfridge{
		onMsg(fridgestate : fridgestate(List)){
			println("fridge state received: ${payloadArg(0)}")
		}
	}Goto waitCmd
	
	
	State exposeroomstate{
		onMsg(exposeroomstate_button : exposeroomstate_button(Cmd)){
			request roomstate -m exposeroomstate : exposeroomstate(Cmd)
		}
	}Transition t2
	whenReply roomstate -> waitroom
	
	State waitroom{
		onMsg(roomstate: roomstate(List)){
			println("room state received: ${payloadArg(0)}")
		}
	}Goto waitCmd
}
	

QActor user context ctxfridge{
	State s0 initial{
		println("User is ready")

	}
	
}