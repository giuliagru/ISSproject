/* Generated by AN DISI Unibo */ 
package it.unibo.console

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Console ( name: String, scope: CoroutineScope  ) : ActorBasicFsm( name, scope ){

	override fun getInitialState() : String{
		return "s0"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
					}
					 transition( edgeName="goto",targetState="waitUpdate", cond=doswitch() )
				}	 
				state("waitUpdate") { //this:State
					action { //it:State
					}
					 transition(edgeName="t08",targetState="updatefridge",cond=whenEvent("fridgestate"))
					transition(edgeName="t09",targetState="updateroom",cond=whenEvent("roomstate"))
					transition(edgeName="t010",targetState="updaterobotpos",cond=whenEvent("robotposition"))
					transition(edgeName="t011",targetState="updaterobotaction",cond=whenEvent("robotaction"))
					transition(edgeName="t012",targetState="updaterobotdest",cond=whenEvent("robotdest"))
					transition(edgeName="t013",targetState="handlerobotmsg",cond=whenEvent("food_notavailable"))
				}	 
				state("updatefridge") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("fridgestate(X)"), Term.createTerm("fridgestate(List)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
										println("SONO QUI!")
													val L = payloadArg(0)
													println(L)
													val my = myself							
													val t = itunibo.utils.prepareToSend(L)	
													val OnFridge = t["fridge"].toString()				
								utils.utilsFrontend.updateFrontend( my, OnFridge  )
						}
					}
					 transition( edgeName="goto",targetState="waitUpdate", cond=doswitch() )
				}	 
				state("updateroom") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("roomstate(X)"), Term.createTerm("roomstate(St)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
												
												val L = payloadArg(0)
												println(L)
												val my = myself							
												val t = itunibo.utils.prepareToSend(L)	
												val OnRobot = t["robot"].toString()
												val OnPantry = t["pantry"].toString()
												val OnDish = t["dishwasher"].toString()
												val OnTable = t["table"].toString()
								utils.utilsFrontend.updateFrontend( my, OnRobot  )
								utils.utilsFrontend.updateFrontend( my, OnPantry  )
								utils.utilsFrontend.updateFrontend( my, OnDish  )
								utils.utilsFrontend.updateFrontend( my, OnTable  )
						}
					}
					 transition( edgeName="goto",targetState="waitUpdate", cond=doswitch() )
				}	 
				state("updaterobotpos") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("robotposition(X)"), Term.createTerm("robotposition(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("ROBOT POS:")
								println(payloadArg(0))
								 val my = myself	 
								utils.utilsFrontend.updatePositionFrontend( my, payloadArg(0)  )
						}
					}
					 transition( edgeName="goto",targetState="waitUpdate", cond=doswitch() )
				}	 
				state("updaterobotaction") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("robotaction(X)"), Term.createTerm("robotaction(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("ROBOT ACTION:")
								println(payloadArg(0))
								 val my = myself	 
								utils.utilsFrontend.updateTaskFrontend( my, payloadArg(0)  )
						}
					}
					 transition( edgeName="goto",targetState="waitUpdate", cond=doswitch() )
				}	 
				state("updaterobotdest") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("robotdest(Dest,X,Y)"), Term.createTerm("robotdest(Dest,X,Y)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("ROBOT GOAL:")
								println(payloadArg(0))
								 
												val my = myself	
												val FormattedDest = ":" + payloadArg(0) + " (" + payloadArg(1) + "," + payloadArg(2) +"))"
												println(FormattedDest)
												
								utils.utilsFrontend.updateGoalToFrontend( my, FormattedDest  )
						}
					}
					 transition( edgeName="goto",targetState="waitUpdate", cond=doswitch() )
				}	 
				state("handlerobotmsg") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("food_notavailable(Foodcode,Quantity)"), Term.createTerm("food_notavailable(Foodcode,Quantity)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("Maitre | knows ${payloadArg(0)} ${payloadArg(1)} isn't available")
								 val my = myself	 
								utils.utilsFrontend.updateFrontend( my, "warning"  )
						}
					}
					 transition( edgeName="goto",targetState="waitUpdate", cond=doswitch() )
				}	 
			}
		}
}
